# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import collections.abc
import typing
from qcs_sdk.client import QCSClient
from . import api
from . import isa
from . import translation

class ConnectionStrategy:
    r"""
    The connection strategy to use when submitting and retrieving jobs from a QPU.
    """
    def __getnewargs__(self) -> tuple[str] | tuple[()]: ...
    def __repr__(self) -> builtins.str:
        r"""
        Implements `__repr__` for Python in terms of the Rust
        [`Debug`](std::fmt::Debug) implementation.
        """
    @staticmethod
    def default() -> ConnectionStrategy: ...
    def get_endpoint_id(self) -> builtins.str: ...
    @typing.final
    class DirectAccess(ConnectionStrategy):
        r"""
        Connect directly to the default endpoint, bypassing the gateway. Should only be used when you
        have direct network access and an active reservation.
        """
        __match_args__ = ()
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls) -> ConnectionStrategy.DirectAccess: ...
    
    @typing.final
    class EndpointId(ConnectionStrategy):
        r"""
        Connect directly to a specific endpoint using its ID.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: builtins.str) -> ConnectionStrategy.EndpointId: ...
    
    @typing.final
    class Gateway(ConnectionStrategy):
        r"""
        Connect through the publicly accessible gateway.
        """
        __match_args__ = ()
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls) -> ConnectionStrategy.Gateway: ...
    

class MemoryValues:
    r"""
    A row of data containing the contents of each memory region at the end of a job.
    """
    def __new__(cls, values: typing.Any) -> MemoryValues: ...
    @typing.final
    class Binary(MemoryValues):
        r"""
        Values that correspond to a memory region declared with the BIT or OCTET data type.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.int]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[builtins.int]) -> MemoryValues.Binary: ...
    
    @typing.final
    class Integer(MemoryValues):
        r"""
        Values that correspond to a memory region declared with the INTEGER data type.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.int]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[builtins.int]) -> MemoryValues.Integer: ...
    
    @typing.final
    class Real(MemoryValues):
        r"""
        Values that correspond to a memory region declared with the REAL data type.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.float]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[builtins.float]) -> MemoryValues.Real: ...
    

@typing.final
class QPUResultData:
    r"""
    This struct encapsulates data returned from the QPU after executing a job.
    """
    @property
    def mappings(self) -> builtins.dict[builtins.str, builtins.str]:
        r"""
        Mappings of a memory region (ie. "ro[0]") to its key name in `readout_values` (ie. "q0").
        """
    @property
    def memory_values(self) -> builtins.dict[builtins.str, MemoryValues]:
        r"""
        The final contents of each memory region, keyed on region name.
        """
    @property
    def readout_values(self) -> builtins.dict[builtins.str, ReadoutValues]:
        r"""
        Mapping of a readout values identifier (ie. "q0") to a set of `ReadoutValues`.
        """
    def __new__(cls, mappings: typing.Mapping[builtins.str, builtins.str], readout_values: typing.Mapping[builtins.str, ReadoutValues], memory_values: typing.Mapping[builtins.str, MemoryValues]) -> QPUResultData:
        r"""
        Construct a new `QPUResultData` from mappings and values.
        """
    def to_raw_readout_data(self) -> RawQPUReadoutData:
        r"""
        Get the raw readout data as a flattened structure.
        """

@typing.final
class RawQPUReadoutData:
    r"""
    A wrapper type for data returned by the QPU in a more flat structure than
    [`QpuResultData`] offers. This makes it more convenient to work with
    the data if you don't care what type of number the readout values for
    each register contains.
    """
    @property
    def mappings(self) -> builtins.dict[builtins.str, builtins.str]: ...
    @property
    def memory_values(self) -> builtins.dict[builtins.str, list]: ...
    @property
    def readout_values(self) -> builtins.dict[builtins.str, list]: ...
    def __repr__(self) -> builtins.str:
        r"""
        Implements `__repr__` for Python in terms of the Rust
        [`Debug`](std::fmt::Debug) implementation.
        """

class ReadoutValues:
    r"""
    A row of readout values from the QPU. Each row contains all the values emitted to a
    memory reference across all shots.
    """
    def __new__(cls, values: typing.Any) -> ReadoutValues: ...
    @typing.final
    class Complex(ReadoutValues):
        r"""
        Complex readout values
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.complex]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[builtins.complex]) -> ReadoutValues.Complex: ...
    
    @typing.final
    class Integer(ReadoutValues):
        r"""
        Integer readout values
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.int]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[builtins.int]) -> ReadoutValues.Integer: ...
    
    @typing.final
    class Real(ReadoutValues):
        r"""
        Real numbered readout values
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.float]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[builtins.float]) -> ReadoutValues.Real: ...
    

def list_quantum_processors(client: typing.Optional[QCSClient] = None, timeout: typing.Optional[builtins.float] = None) -> builtins.list[builtins.str]: ...

def list_quantum_processors_async(client: typing.Optional[QCSClient] = None, timeout: typing.Optional[builtins.float] = None) -> collections.abc.Awaitable[builtins.list[builtins.str]]: ...

