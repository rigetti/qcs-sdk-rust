# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import collections.abc
import datetime
import enum
import numpy
import numpy.typing
import typing
from qcs_sdk.compiler.quilc import CompilerOpts, NativeQuilMetadata, QuilcClient
from qcs_sdk.qpu import QPUResultData
from qcs_sdk.qpu.api import ExecutionOptions
from qcs_sdk.qpu.translation import TranslationOptions
from qcs_sdk.qvm import QVMClient, QVMResultData
from quil.program import Program
from . import _qcs_sdk
from . import client
from . import qpu
from . import qvm

@typing.final
class CompilationResult:
    r"""
    The result of compiling a Quil program to native quil with `quilc`
    """
    @property
    def native_quil_metadata(self) -> typing.Optional[NativeQuilMetadata]:
        r"""
        Metadata about the compiled program
        """
    @property
    def program(self) -> Program:
        r"""
        The compiled program
        """

@typing.final
class ExeParameter:
    @property
    def index(self) -> builtins.int: ...
    @index.setter
    def index(self, value: builtins.int) -> None: ...
    @property
    def name(self) -> builtins.str: ...
    @name.setter
    def name(self, value: builtins.str) -> None: ...
    @property
    def value(self) -> builtins.float: ...
    @value.setter
    def value(self, value: builtins.float) -> None: ...
    def __new__(cls, name: builtins.str, index: builtins.int, value: builtins.float) -> ExeParameter: ...

@typing.final
class Executable:
    r"""
    A builder interface for executing Quil programs on QVMs and QPUs.
    
    # Example
    
    This example executes a program on a QVM, specified by the `qvm_url` in the `QCSClient::
    
        from qcs_sdk import Executable
        from qcs_sdk.client import QCSClient
        from qcs_sdk.qvm import QVMClient
    
        PROGRAM = """
        DECLARE ro BIT[2]
    
        H 0
        CNOT 0 1
    
        MEASURE 0 ro[0]
        MEASURE 1 ro[1]
        """
    
        async def run():
            client = QVMClient.new_http(QCSClient.load().qvm_url)
            result = await Executable(PROGRAM, shots=4).execute_on_qvm_async()
            let data = result.result_data
                                .to_register_map()
                                .expect("should convert to readout map")
                                .get_register_matrix("ro")
                                .expect("should have data in ro")
                                .as_integer()
                                .expect("should be integer matrix")
                                .to_owned();
    
            // In this case, we ran the program for 4 shots, so we know the number of rows is 4.
            assert_eq!(data.nrows(), 4);
            for shot in data.rows() {
                // Each shot will contain all the memory, in order, for the vector (or "register") we
                // requested the results of. In this case, "ro" (the default).
                assert_eq!(shot.len(), 2);
                // In the case of this particular program, we know ro[0] should equal ro[1]
                assert_eq!(shot[0], shot[1]);
            }
    
        def main():
            import asyncio
            asyncio.run(run())
    
            # "ro" is the only source read from by default if you don't specify `registers`.
    
            # We first convert the readout data to a ``RegisterMap`` to get a mapping of registers
            # (ie. "ro") to a [`RegisterMatrix`], `M`, where M[`shot`][`index`] is the value for
            # the memory offset `index` during shot `shot`.
            # There are some programs where QPU readout data does not fit into a [`RegisterMap`], in
            # which case you should build the matrix you need from [`QpuResultData`] directly. See
            # the [`RegisterMap`] documentation for more information on when this transformation
            # might fail.
    """
    def __new__(cls, quil: builtins.str, registers: typing.Sequence[builtins.str] = [], parameters: typing.Sequence[ExeParameter] = [], shots: typing.Optional[builtins.int] = None, quilc_client: typing.Optional[QuilcClient] = None, compiler_options: typing.Optional[CompilerOpts] = None) -> Executable: ...
    def execute_on_qpu(self, quantum_processor_id: builtins.str, endpoint_id: typing.Optional[builtins.str] = None, translation_options: typing.Optional[TranslationOptions] = None, execution_options: typing.Optional[ExecutionOptions] = None) -> ExecutionData: ...
    def execute_on_qpu_async(self, quantum_processor_id: builtins.str, endpoint_id: typing.Optional[builtins.str] = None, translation_options: typing.Optional[TranslationOptions] = None, execution_options: typing.Optional[ExecutionOptions] = None) -> collections.abc.Awaitable[ExecutionData]: ...
    def execute_on_qvm(self, client: QVMClient) -> ExecutionData: ...
    def execute_on_qvm_async(self, client: QVMClient) -> collections.abc.Awaitable[ExecutionData]: ...
    def retrieve_results(self, job_handle: JobHandle) -> ExecutionData: ...
    def retrieve_results_async(self, job_handle: JobHandle) -> collections.abc.Awaitable[ExecutionData]: ...
    def submit_to_qpu(self, quantum_processor_id: builtins.str, endpoint_id: typing.Optional[builtins.str] = None, translation_options: typing.Optional[TranslationOptions] = None, execution_options: typing.Optional[ExecutionOptions] = None) -> JobHandle: ...
    def submit_to_qpu_async(self, quantum_processor_id: builtins.str, endpoint_id: typing.Optional[builtins.str] = None, translation_options: typing.Optional[TranslationOptions] = None, execution_options: typing.Optional[ExecutionOptions] = None) -> collections.abc.Awaitable[ExecutionData]: ...

@typing.final
class ExecutionData:
    r"""
    The result of executing an [`Executable`](crate::Executable)
    """
    @property
    def duration(self) -> typing.Optional[datetime.timedelta]:
        r"""
        The time it took to execute the program on the QPU, not including any network or queueing
        time. If paying for on-demand execution, this is the amount you will be billed for.
        
        This will always be `None` for QVM execution.
        """
    @property
    def result_data(self) -> ResultData:
        r"""
        The [`ResultData`] that was read from the [`Executable`](crate::Executable).
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __getstate__(self) -> bytes: ...
    def __new__(cls, result_data: typing.Optional[ResultData] = None, duration: typing.Optional[datetime.timedelta] = None) -> ExecutionData:
        r"""
        Python constructor for `ExecutionData`.
        
        `result_data` is optional here
        because pickling an object requires calling __new__ without arguments.
        """
    def __setstate__(self, state: bytes) -> None: ...

class ExecutionError(QcsSdkError):
    r"""
    Errors which can occur when executing a program.
    """
    ...

@typing.final
class JobHandle:
    ...

class ListQuantumProcessorsError(QcsSdkError):
    r"""
    API Errors encountered when trying to list available quantum processors.
    """
    ...

class QcsSdkError(builtins.Exception):
    r"""
    Base exception type for errors raised by this package.
    """
    ...

class RegisterData:
    r"""
    Data resulting from [`Executable::execute_on_qvm`](`crate::Executable::execute_on_qvm`)
    
    This represents a single vector (or "register") of typed memory across some number of shots.
    The register corresponds to the usage of a `DECLARE` instruction in Quil, and the name of that
    register should be provided with [`Executable::read_from`](`crate::Executable::read_from`).
    
    There is a variant of this enum for each type of data that a register could hold. The register
    is represented as a 2-dimensional array `M` where the value `M[shot_number][memory_index]`
    represents the value at `memory_index` for `shot_number`.
    
    # Usage
    
    Typically, you will be interacting with this data through the [`crate::ResultData`] of an
    [`crate::ExecutionData`] returned after running a program. In those cases, you'll probably
    want to convert it to a readout map using [`crate::ResultData.to_register_map()`]. This
    will give you each register in the form of a [`crate::RegisterMatrix`] which is similar
    but backed by an [`ndarray::Array2`] and more convenient for working with matrices.
    
    If you are interacting with [`RegisterData`] directly, then you should already know what type of data it _should_
    have, so you can  use the [`mod@enum_as_inner`] methods (e.g. [`RegisterData::into_i8`]) in order to
    convert any variant type to its inner data.
    """
    def __new__(cls, values: typing.Any) -> RegisterData: ...
    def as_ndarray(self) -> typing.Any:
        r"""
        Returns the values as a 2D numpy ndarray.
        """
    @typing.final
    class Complex32(RegisterData):
        r"""
        Results containing complex numbers.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.list[builtins.complex]]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[typing.Sequence[builtins.complex]]) -> RegisterData.Complex32: ...
    
    @typing.final
    class F64(RegisterData):
        r"""
        Corresponds to the Quil `REAL` type.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.list[builtins.float]]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[typing.Sequence[builtins.float]]) -> RegisterData.F64: ...
    
    @typing.final
    class I16(RegisterData):
        r"""
        Corresponds to the Quil `INTEGER` type.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.list[builtins.int]]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[typing.Sequence[builtins.int]]) -> RegisterData.I16: ...
    
    @typing.final
    class I8(RegisterData):
        r"""
        Corresponds to the Quil `BIT` or `OCTET` types.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.list[builtins.list[builtins.int]]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: typing.Sequence[typing.Sequence[builtins.int]]) -> RegisterData.I8: ...
    

@typing.final
class RegisterMap:
    r"""
    A mapping of a register name (ie. "ro") to a [`RegisterMatrix`] containing the values for the
    register.
    """
    def __contains__(self, key: builtins.str) -> builtins.bool: ...
    def __getitem__(self, item: builtins.str) -> RegisterMatrix: ...
    def __iter__(self) -> RegisterMapKeysIter: ...
    def __len__(self) -> builtins.int: ...
    def get(self, key: builtins.str, default: typing.Optional[RegisterMatrix]) -> typing.Optional[RegisterMatrix]: ...
    def get_register_matrix(self, register_name: builtins.str) -> typing.Optional[RegisterMatrix]: ...
    def items(self) -> RegisterMapItemsIter: ...
    def keys(self) -> RegisterMapKeysIter: ...
    def values(self) -> RegisterMapValuesIter: ...

@typing.final
class RegisterMapItemsIter:
    def __iter__(self) -> RegisterMapItemsIter: ...
    def __next__(self) -> typing.Optional[tuple[builtins.str, RegisterMatrix]]: ...

@typing.final
class RegisterMapKeysIter:
    def __iter__(self) -> RegisterMapKeysIter: ...
    def __next__(self) -> typing.Optional[builtins.str]: ...

@typing.final
class RegisterMapValuesIter:
    def __iter__(self) -> RegisterMapValuesIter: ...
    def __next__(self) -> typing.Optional[RegisterMatrix]: ...

class RegisterMatrix:
    r"""
    A 2 dimensional matrix of register values.
    """
    def to_ndarray(self) -> typing.Any: ...
    @typing.final
    class Complex(RegisterMatrix):
        r"""
        Complex numbered register
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> numpy.typing.NDArray[numpy.complex128]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: numpy.typing.NDArray[numpy.complex128]) -> RegisterMatrix.Complex: ...
    
    @typing.final
    class Integer(RegisterMatrix):
        r"""
        Integer register
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> numpy.typing.NDArray[numpy.int64]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: numpy.typing.NDArray[numpy.int64]) -> RegisterMatrix.Integer: ...
    
    @typing.final
    class Real(RegisterMatrix):
        r"""
        Real numbered register
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> numpy.typing.NDArray[numpy.float64]: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: numpy.typing.NDArray[numpy.float64]) -> RegisterMatrix.Real: ...
    

class RegisterMatrixConversionError(QcsSdkError):
    r"""
    Error that may occur when building a `RegisterMatrix` from execution data.
    """
    ...

class ResultData:
    r"""
    Represents the two possible types of data returned from either the QVM or a real QPU.
    Each variant contains the original data returned from its respective executor.
    
    # Usage
    
    Your usage of [`ResultData`] will depend on the types of programs you are running and where.
    The `to_register_map()` method will attempt to build a [`RegisterMap`] out of the data, where each
    register name is mapped to a 2-dimensional rectangular [`RegisterMatrix`] where each row
    represents the final values in each register index for a particular shot. This is often the
    desired form of the data and it is _probably_ what you want. This transformation isn't always
    possible, in which case `to_register_map()` will return an error.
    
    To understand why this transformation can fail, we need to understand a bit about how readout data is
    returned from the QVM and from a real QPU:
    
    The QVM treats each `DECLARE` statement as initialzing some amount of memory. This memory works
    as one might expect it to. It is zero-initialized on each shot, and subsequent writes to the same region
    overwrite the previous value. The QVM returns memory at the end of every shot. This means
    we get the last value in every memory reference for each shot, which is exactly the
    representation we want for a [`RegisterMatrix`]. For this reason, `to_register_map()` should
    always succeed for [`ResultData::Qvm`].
    
    The QPU on the other hand doesn't use the same memory model as the QVM. Each memory reference
    (ie. "ro\[0\]") is more like a stream than a value in memory. Every `MEASURE` to a memory
    reference emits a new value to said stream. This means that the number of values per memory
    reference can vary per shot. For this reason, it's not always clear what the final value in
    each shot was for a particular reference. When this is the case, `to_register_map()` will return
    an error as it's impossible to build a correct [`RegisterMatrix`] from the data without
    knowing the intent of the program that was run. Instead, it's recommended to build the
    [`RegisterMatrix`] you need from the inner [`QpuResultData`] data using the knowledge of your
    program to choose the correct readout values for each shot.
    """
    def __new__(cls, values: typing.Any) -> ResultData: ...
    def __repr__(self) -> builtins.str:
        r"""
        Implements `__repr__` for Python in terms of the Rust
        [`Debug`](std::fmt::Debug) implementation.
        """
    def to_raw_readout_data(self) -> dict[str, list] | RawQPUReadoutData:
        r"""
        Get the raw readout data from either QPU or QVM result.
        """
    def to_register_map(self) -> RegisterMap:
        r"""
        Convert [`ResultData`] from its inner representation as [`QvmResultData`] or
        [`QpuResultData`] into a [`RegisterMap`]. The [`RegisterMatrix`] for each register will be
        constructed such that each row contains all the final values in the register for a single shot.
        
        # Errors
        
        Returns a [`RegisterMatrixConversionError`] if the inner execution data for any of the
        registers would result in a jagged matrix. [`QpuResultData`] data is captured per measure,
        meaning a value is returned for every measure to a memory reference, not just once per shot.
        This is often the case in programs that use mid-circuit measurement or dynamic control flow,
        where measurements to the same memory reference might occur multiple times in a shot, or be
        skipped conditionally. In these cases, building a rectangular [`RegisterMatrix`] would
        necessitate making assumptions about the data that could skew the data in undesirable ways.
        Instead, it's recommended to manually build a matrix from [`QpuResultData`] that accurately
        selects the last value per-shot based on the program that was run.
        """
    @typing.final
    class Qpu(ResultData):
        r"""
        Readout data returned from the QPU, stored as [`QpuResultData`]
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> QPUResultData: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: QPUResultData) -> ResultData.Qpu: ...
    
    @typing.final
    class Qvm(ResultData):
        r"""
        Data returned from the QVM, stored as [`QvmResultData`]
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> QVMResultData: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
        def __len__(self) -> builtins.int: ...
        def __new__(cls, _0: QVMResultData) -> ResultData.Qvm: ...
    

@typing.final
class Service(enum.Enum):
    r"""
    The external services that this SDK may connect to. Used to differentiate between networking
    issues in [`Error::Connection`].
    """
    Quilc = ...
    r"""
    The open source [`quilc`](https://github.com/quil-lang/quilc) compiler.
    
    This compiler must be running before calling [`Executable::execute_on_qpu`] unless the
    [`Executable::compile_with_quilc`] option is set to `false`. By default, it's assumed that
    this is running on `tcp://localhost:5555`, but this can be overridden via
    `[profiles.<profile_name>.applications.pyquil.quilc_url]` in your `.qcs/settings.toml` file.
    """
    Qvm = ...
    r"""
    The open source [`qvm`](https://github.com/quil-lang/qvm) simulator.
    
    This simulator must be running before calling [`Executable::execute_on_qvm`]. By default,
    it's assumed that this is running on `http://localhost:5000`, but this can be overridden via
    `[profiles.<profile_name>.applications.pyquil.qvm_url]` in your `.qcs/settings.toml` file.
    """
    Qcs = ...
    r"""
    The connection to [`QCS`](https://docs.rigetti.com/qcs/), the API for authentication,
    QPU lookup, and translation.
    
    You should be able to reach this service as long as you have a connection to the internet.
    """
    Qpu = ...
    r"""
    The connection to the QPU itself. You can only connect to the QPU from an authorized network
    (like QCS JupyterLab).
    """

def _gather_diagnostics() -> builtins.str: ...

def reset_logging() -> None: ...

