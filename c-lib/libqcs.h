/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


/**
 * The return value of [`run_program_on_qvm`] or [`run_program_on_qpu`].
 *
 * # Safety
 * In order to properly free the memory allocated in this struct, call [`free_program_result`]
 * with any instances created.
 *
 * # Example
 * If you have a Quil program with an "ro" register containing two items:
 *
 * ```quil
 * DECLARE ro BIT[2]
 * ```
 * and you run that program 3 times (shots)
 *
 * ```C
 * ProgramResult result = run_program_on_qvm(program, 3, "ro");
 * ```
 * If `error` is `NULL` then `results_by_shot` will look something like:
 *
 * ```
 * results_by_shot = [[0, 0], [0, 0], [0, 0]]
 * ```
 *
 * where `results_by_shot[shot][bit]` can access the value of `ro[bit]` for a given `shot`.
 */
typedef enum ProgramResult_Tag {
    ProgramResult_Error,
    ProgramResult_Byte,
    ProgramResult_Real,
} ProgramResult_Tag;

typedef struct ProgramResult_Byte_Body {
    unsigned short number_of_shots;
    unsigned short shot_length;
    char **data_per_shot;
} ProgramResult_Byte_Body;

typedef struct ProgramResult_Real_Body {
    unsigned short number_of_shots;
    unsigned short shot_length;
    double **data_per_shot;
} ProgramResult_Real_Body;

typedef struct ProgramResult {
    ProgramResult_Tag tag;
    union {
        struct {
            char *error;
        };
        ProgramResult_Byte_Body byte;
        ProgramResult_Real_Body real;
    };
} ProgramResult;

/**
 * Frees the memory of a [`QVMResponse`] as allocated by [`run_program_on_qvm`]
 *
 * # Safety
 * This function should only be called with the result of [`run_program_on_qvm`]
 */
void free_program_result(struct ProgramResult response);

/**
 * Given a Quil program as a string, run that program on a QPU
 *
 * # Safety
 *
 * In order to run this function safely, you must provide the return value from this
 * function to [`crate::free_program_result`] once you're done with it. The inputs `program`,
 * `register_name`, and `qpu_id` must be valid, nul-terminated, non-null strings which remain
 * constant for the duration of this function.
 *
 * # Usage
 *
 * In order to execute, you must have an active reservation for the QPU you're targeting.
 *
 * ## Configuration
 *
 * Valid settings and secrets must be set either in ~/.qcs or by setting the OS environment
 * variables `QCS_SECRETS_FILE_PATH` and `QCS_SETTINGS_FILE_PATH` for secrets and settings
 * respectively. `QCS_PROFILE_NAME` can also be used to choose a different profile in those
 * configuration files.
 *
 * # Arguments
 *
 * 1. `program`: A string containing a valid Quil program. Any measurements that you'd like
 * to get back out must be in a register matching `register_name`. For example, if you have
 * `MEASURE 0 ro[0]` then `register_name` should be `"ro"`.
 * 2. `num_shots`: the number of times you'd like to run the program.
 * 3. `register_name`: the name of the register in the `program` that is being measured to.
 * 4. `qpu_id`: the ID of the QPU to run on (e.g. `"Aspen-9"`)
 *
 * # Errors
 *
 * This program will return a [`crate::ProgramResult`] with an `error` attribute which will be
 * `NULL` if successful or a human readable description of the error that occurred.
 */
struct ProgramResult run_program_on_qpu(char *program, unsigned short num_shots, char *register_name, char *qpu_id);

/**
 * Given a Quil program as a string, run that program on a local QVM.
 *
 * # Safety
 *
 * In order to run this function safely, you must provide the return value from this
 * function to [`crate::free_program_result`] once you're done with it. The inputs `program` and
 * `register_name` must be valid, nul-terminated, non-null strings which remain constant for
 * the duration of this function.
 *
 * # Usage
 *
 * In order to execute, QVM must be running at <http://localhost:5000>.
 *
 * # Arguments
 *
 * 1. `program`: A string containing a valid Quil program. Any measurements that you'd like
 * to get back out must be in a register matching `register_name`. For example, if you have
 * `MEASURE 0 ro[0]` then `register_name` should be `"ro"`.
 * 2. `num_shots`: the number of times you'd like to run the program.
 * 3. `register_name`: the name of the register in the `program` that is being measured to.
 *
 * # Errors
 *
 * This program will return a [`ProgramResult`] with a `error` attribute. That `error` attribute will
 * either be `NULL` if successful, or a human readable description of the error that occurred.
 */
struct ProgramResult run_program_on_qvm(char *program, unsigned short num_shots, char *register_name);
